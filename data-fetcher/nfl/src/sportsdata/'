package sportsdata

import (
  "io"
  "encoding/xml"
  "log"
  "models"
  "reflect"
  "strconv"
  "time"
  "os"
  "github.com/BurntSushi/ty"
)

func findAttrByName(attrs []xml.Attr, name string) string {
  for _, attr := range(attrs) {
    if attr.Name.Local == name {
      return attr.Value
    }
  }
  return ""
}


var inElement string // Tracks where we are in our traversal

type XmlResult struct {
  Results []interface{}
}

func (res XmlResult) AsTeams() []models.Team {
  teams := make([]models.Team, len(res.Results))
  for i, arg := range res.Results { teams[i] = arg.(models.Team) }
  return teams
}

func (res XmlResult) AsGames() []models.Game {
  games := make([]models.Game, len(res.Results))
  for i, arg := range res.Results { games[i] = arg.(models.Game) }
  return games
}

func ParseXml(xmlStream io.ReadCloser, handlerFunc interface{}) interface{} {
/*
func Map(f interface{}, xs interface{}) interface{} {
    vf := reflect.ValueOf(f)
    vxs := reflect.ValueOf(xs)

    tys := reflect.SliceOf(vf.Type().Out(0))
    vys := reflect.MakeSlice(tys, vxs.Len(), vxs.Len())

    for i := 0; i < vxs.Len(); i++ {
        y := vf.Call([]reflect.Value{vxs.Index(i)})[0]
        vys.Index(i).Set(y)
    }
    return vys.Interface()
}


func Map(f, xs interface{}) interface{} {
    chk := ty.Check(
        new(func(func(ty.A) ty.B, []ty.A) []ty.B),
        f, xs)
    vf, vxs, tys := chk.Args[0], chk.Args[1], chk.Returns[0]

    xsLen := vxs.Len()
    vys := reflect.MakeSlice(tys, xsLen, xsLen)
    for i := 0; i < xsLen; i++ {
        vy := vf.Call([]reflect.Value{vxs.Index(i)})[0]
        vys.Index(i).Set(vy)
    }
    return vys.Interface()
}

*/

  // PICK UP HERE, don't need to validate all args
  chk := ty.Check(new(func(io.ReadCloser, func(*xml.Decoder, xml.StartElement) *ty.A) []*ty.A), xmlStream, handlerFunc)
  handler, sliceType := chk.Args[1], chk.Returns[1]

  decoder := xml.NewDecoder(xmlStream)
  results := make([]interface{}, 0)
  for {
    // Read tokens from the XML document in a stream.
    t, _ := decoder.Token()
    if t == nil {
      break
    }
    // Inspect the type of the token just read.
    switch element := t.(type) {
    case xml.StartElement:
      // If we just read a StartElement token
      inElement = element.Name.Local
      result := handler.Call([]reflect.Value{decoder, element})
      log.Println(result)
      if reflect.TypeOf(result) != nil {
        results = append(results, &result)
        if len(results) > 1 {
          os.Exit(1)
        }
      }
    default:
    }
  }
  return XmlResult{results}
}


// Possibly useful for statekeeping as we're going through things
var conference string
var division string
// Returns a models.Team object
func ParseStandings(decoder *xml.Decoder, element xml.StartElement) *models.Team {
  switch element.Name.Local {

  case "conference":
    conference = findAttrByName(element.Attr, "name")

  case "division":
      division = findAttrByName(element.Attr, "name")

  case "team":
    var team = models.Team{}
    //decoder.DecodeElement(&team, &element)
    team.Abbrev = findAttrByName(element.Attr, "id")
    team.Name = findAttrByName(element.Attr, "name")
    team.Market = findAttrByName(element.Attr, "market")
    team.Country = "USA"
    team.Conference = conference
    team.Division = division
    return &team

  default:
  }
  return nil
}

var seasonYear int
var seasonType string
var seasonWeek int
var currentGame *models.Game
var count = 0
const timeFormat = "2012-09-06T00:30:00+00:00"
func ParseGames(decoder *xml.Decoder, element xml.StartElement) *models.Game {
  switch element.Name.Local {

  case "season":
    seasonType = findAttrByName(element.Attr, "type")
    seasonYear, _ = strconv.Atoi(findAttrByName(element.Attr, "season"))

  case "week":
    seasonWeek, _ = strconv.Atoi(findAttrByName(element.Attr, "week"))

  case "game":
    count++
    var game = models.Game{}
    game.StatsId = findAttrByName(element.Attr, "id")
    game.SeasonType = seasonType
    game.SeasonWeek = seasonWeek
    game.SeasonYear = seasonYear
    game.GameTime, _ = time.Parse(timeFormat, findAttrByName(element.Attr, "scheduled"))
    game.GameDay = game.GameTime.Truncate(time.Hour * 24)
    game.HomeTeam = findAttrByName(element.Attr, "home")
    game.AwayTeam = findAttrByName(element.Attr, "away")
    game.Status = findAttrByName(element.Attr, "status")
    currentGame = &game;
    return &game

  case "venue":
    venue := models.Venue{}
    venue.StatsId = findAttrByName(element.Attr, "id")
    venue.Country = findAttrByName(element.Attr, "country")
    venue.Name = findAttrByName(element.Attr, "name")
    venue.City = findAttrByName(element.Attr, "city")
    venue.State = findAttrByName(element.Attr, "state")
    venue.Type = findAttrByName(element.Attr, "type")
    venue.Surface = findAttrByName(element.Attr, "surface")
    log.Println("Setting venue")
    log.Println(currentGame)
    currentGame.Venue = venue
    log.Println(currentGame)
    log.Println(venue)
  case "broadcast":
    log.Println("Setting Network")
    currentGame.Network = findAttrByName(element.Attr, "network")
  default:
  }
  return nil

}
